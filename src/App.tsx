import { useState, useEffect, useCallback } from 'react';
import type { AppData, Team, Tournament, Player, Game } from './types';
import { loadData, saveData } from './lib/storage';
import { mockPlayers, mockGames, mockTournament, mockTeam } from './data/mockData';
import { TeamsHub } from './components/ui/TeamsHub';
import { Sidebar } from './components/ui/Sidebar';
import { AppHeader } from './components/layout/AppHeader';
import { AppModals } from './components/layout/AppModals';
import type { ModalType } from './components/layout/AppModals';
import { AppContent } from './components/layout/AppContent';
import './index.css';
import { HierarchyStepper } from './components/ui/HierarchyStepper';

type TabId = 'players' | 'tournaments' | 'team' | 'games' | 'stats';


// TABS moved to dynamic generation based on state

function App() {
  const [activeTab, setActiveTab] = useState<TabId>('players');
  const [data, setData] = useState<AppData>({ teams: [], tournaments: [], players: [], games: [] });
  const [activeTeam, setActiveTeam] = useState<Team | null>(null);
  const [activeTournament, setActiveTournament] = useState<Tournament | null>(null);
  const [modalType, setModalType] = useState<ModalType>(null);
  const [editItem, setEditItem] = useState<Team | Tournament | Player | Game | null>(null);
  const [useMockData, setUseMockData] = useState(false);
  const [saveStatus, setSaveStatus] = useState<'saved' | 'saving' | 'unsaved'>('saved');
  const [lastSaveTime, setLastSaveTime] = useState<Date | null>(null);
  const [highlightedItemId, setHighlightedItemId] = useState<string | null>(null);


  useEffect(() => {
    const init = async () => {
      const stored = await loadData();
      setData(stored);

      // Restore session
      const savedTeamId = localStorage.getItem('tsm_active_team');
      if (savedTeamId) {
        const team = stored.teams.find(t => t.id === savedTeamId);
        if (team) {
          setActiveTeam(team);
          const savedTourneyId = localStorage.getItem('tsm_active_tournament');
          if (savedTourneyId) {
            const tourney = stored.tournaments.find(t => t.id === savedTourneyId);
            if (tourney && tourney.participatingTeamIds?.includes(team.id)) {
              setActiveTournament(tourney);
            }
          }
        }
      }
    };
    init();
  }, []);



  // Persist session context
  useEffect(() => {
    if (activeTeam) {
      localStorage.setItem('tsm_active_team', activeTeam.id);
    } else {
      localStorage.removeItem('tsm_active_team');
    }

    if (activeTournament) {
      localStorage.setItem('tsm_active_tournament', activeTournament.id);
    } else {
      localStorage.removeItem('tsm_active_tournament');
    }
  }, [activeTeam, activeTournament]);

  // Filter tournaments by active team
  const filteredTournaments = activeTeam
    ? data.tournaments.filter(t => t.participatingTeamIds?.includes(activeTeam.id))
    : [];

  // Get filtered data
  // Players now belong to Team
  const filteredPlayers = activeTeam
    ? data.players.filter(p => p.teamId === activeTeam.id)
    : [];

  const filteredGames = activeTournament
    ? data.games.filter(g => g.tournamentId === activeTournament.id)
    : useMockData ? mockGames : [];

  // Search scope: All games for the active team
  const searchGames = activeTeam
    ? data.games.filter(g => filteredTournaments.some(t => t.id === g.tournamentId))
    : [];

  // Manual Save Handler
  const handleManualSave = useCallback(async () => {
    setSaveStatus('saving');
    try {
      await saveData(data);
      setSaveStatus('saved');
      setLastSaveTime(new Date());
    } catch (error) {
      console.error('Save failed:', error);
      setSaveStatus('unsaved');
    }
  }, [data]);

  // Handlers
  const handleSaveTeam = useCallback(async (team: Team) => {
    setSaveStatus('saving');
    try {
      const updatedTeams = [...data.teams];
      const idx = updatedTeams.findIndex(t => t.id === team.id);
      if (idx >= 0) updatedTeams[idx] = team;
      else updatedTeams.push(team);

      const newData = { ...data, teams: updatedTeams };
      await saveData(newData);
      setData(newData);
      setActiveTeam(team);
      setModalType(null);
      setEditItem(null);
      setSaveStatus('saved');
      setLastSaveTime(new Date());
    } catch (error) {
      console.error('Save failed:', error);
      alert('Failed to save team changes.');
      setSaveStatus('unsaved');
    }
  }, [data]);

  const handleDeleteTeam = useCallback(async (id: string) => {
    if (window.confirm('Delete this team and all its tournaments, players, and games?')) {
      try {
        const newData = { ...data };
        newData.teams = newData.teams.filter(t => t.id !== id);
        newData.tournaments = newData.tournaments.filter(t => !t.participatingTeamIds?.includes(id));
        newData.players = newData.players.filter(p => p.teamId !== id);
        newData.games = newData.games.filter(g => {
          const tournament = data.tournaments.find(t => t.id === g.tournamentId);
          return tournament && tournament.participatingTeamIds?.includes(id);
        });

        await saveData(newData);
        setData(newData);
        if (activeTeam?.id === id) {
          setActiveTeam(null);
          setActiveTournament(null);
        }
        setUseMockData(false);
      } catch (error) {
        console.error('Delete failed:', error);
        alert('Failed to delete team.');
      }
    }
  }, [data, activeTeam]);

  const handleSaveTournament = useCallback(async (tournament: Tournament) => {
    const isNew = !editItem;
    setSaveStatus('saving');
    try {
      const updatedTournaments = [...data.tournaments];
      const idx = updatedTournaments.findIndex(t => t.id === tournament.id);
      if (idx >= 0) updatedTournaments[idx] = tournament;
      else updatedTournaments.push(tournament);

      const newData = { ...data, tournaments: updatedTournaments };
      await saveData(newData);
      setData(newData);
      setActiveTournament(tournament);
      setModalType(null);
      setEditItem(null);
      setSaveStatus('saved');
      setLastSaveTime(new Date());
      if (isNew) {
        setActiveTab('players');
      }
    } catch (error) {
      console.error('Save failed:', error);
      alert('Failed to save tournament changes.');
      setSaveStatus('unsaved');
    }
  }, [data, editItem]);

  const handleDeleteTournament = useCallback(async (id: string) => {
    if (confirm('Delete this tournament and all its games? Players will remain in the Team Roster.')) {
      try {
        const newData = { ...data };
        newData.tournaments = newData.tournaments.filter(t => t.id !== id);
        newData.games = newData.games.filter(g => g.tournamentId !== id);

        await saveData(newData);
        setData(newData);
        if (activeTournament?.id === id) {
          setActiveTournament(null);
          setActiveTab('tournaments');
        }
        setUseMockData(false);
      } catch (error) {
        console.error('Delete failed:', error);
        alert('Failed to delete tournament.');
      }
    }
  }, [data, activeTournament]);

  const handleSavePlayer = useCallback(async (player: Player) => {
    setSaveStatus('saving');
    try {
      const updatedPlayers = [...data.players];
      const idx = updatedPlayers.findIndex(p => p.id === player.id);
      if (idx >= 0) updatedPlayers[idx] = player;
      else updatedPlayers.push(player);

      const newData = { ...data, players: updatedPlayers };
      await saveData(newData);
      setData(newData);
      setModalType(null);
      setEditItem(null);
      setSaveStatus('saved');
      setLastSaveTime(new Date());
    } catch (error) {
      console.error('Save failed:', error);
      alert('Failed to save player changes.');
      setSaveStatus('unsaved');
    }
  }, [data]);

  const handleBulkImportPlayers = useCallback(async (players: Player[]) => {
    try {
      const newData = { ...data };
      newData.players = [...newData.players, ...players];
      await saveData(newData);
      setData(newData);
      setModalType(null);
    } catch (error) {
      console.error('Bulk import failed:', error);
      alert('Failed to import players.');
    }
  }, [data]);

  const handleSaveGame = useCallback(async (game: Game) => {
    setSaveStatus('saving');
    try {
      const updatedGames = [...data.games];
      const idx = updatedGames.findIndex(g => g.id === game.id);
      if (idx >= 0) updatedGames[idx] = game;
      else updatedGames.push(game);

      const newData = { ...data, games: updatedGames };
      await saveData(newData);
      setData(newData);
      setModalType(null);
      setEditItem(null);
      setSaveStatus('saved');
      setLastSaveTime(new Date());
    } catch (error) {
      console.error('Save failed:', error);
      alert('Failed to save game record.');
      setSaveStatus('unsaved');
    }
  }, [data]);

  const handleDeletePlayer = useCallback(async (id: string) => {
    if (confirm('Delete this player? Game stats will be removed.')) {
      try {
        const newData = { ...data };
        newData.players = newData.players.filter(p => p.id !== id);
        newData.games = newData.games.map(g => ({
          ...g,
          playerStats: g.playerStats.filter(ps => ps.playerId !== id)
        }));

        await saveData(newData);
        setData(newData);
        setModalType(null);
        setEditItem(null);
      } catch (error) {
        console.error('Delete failed:', error);
        alert('Failed to delete player.');
      }
    }
  }, [data]);

  const handleDeleteGame = useCallback(async (id: string) => {
    if (confirm('Delete this game record permanently?')) {
      try {
        const newData = { ...data };
        newData.games = newData.games.filter(g => g.id !== id);

        await saveData(newData);
        setData(newData);
        setModalType(null);
        setEditItem(null);
      } catch (error) {
        console.error('Delete failed:', error);
        alert('Failed to delete game.');
      }
    }
  }, [data]);

  const loadMockData = async () => {
    const mockData: AppData = {
      teams: [mockTeam],
      tournaments: [mockTournament],
      players: mockPlayers,
      games: mockGames
    };
    await saveData(mockData);
    setData(mockData);
    setActiveTeam(mockTeam);
    setActiveTournament(mockTournament);
    setUseMockData(false);
  };





  const handleImportData = useCallback(async (importedData: AppData) => {
    try {
      const validData: AppData = {
        teams: Array.isArray(importedData.teams) ? importedData.teams : [],
        tournaments: Array.isArray(importedData.tournaments) ? importedData.tournaments : [],
        players: Array.isArray(importedData.players) ? importedData.players : [],
        games: Array.isArray(importedData.games) ? importedData.games : []
      };

      if (validData.teams.length === 0) {
        throw new Error('The file contains no teams.');
      }

      if (data.teams.length > 0) {
        if (!confirm('This will overwrite your existing data. Continue?')) {
          return;
        }
      }

      await saveData(validData);
      setData(validData);
      alert(`Success! Loaded ${validData.teams.length} teams. App will now restart.`);
      window.location.reload();
    } catch (err) {
      console.error('IMPORT FAILED:', err);
      alert('Import Failed: ' + (err as Error).message);
    }
  }, [data]);

  const handleStorageReset = useCallback(async () => {
    const newData = await loadData();
    setData(newData);
    setActiveTeam(null);
    setActiveTournament(null);
  }, []);

  // Entry Point: Teams Hub
  if (!activeTeam && !useMockData) {
    return (
      <div className="app">
        <AppHeader
          activeTeam={activeTeam}
          saveStatus={saveStatus}
          lastSaveTime={lastSaveTime}
          onManualSave={handleManualSave}
          onSwitchTeam={() => setActiveTeam(null)}
          onOpenStorage={() => setModalType('storage')}
          data={data}
          filteredPlayers={filteredPlayers}
          searchGames={searchGames}
          onNavigateSearch={() => { }}
          onOpenHelp={() => setModalType('help')}
        />
        <div>
          <TeamsHub
            teams={data.teams}
            tournaments={data.tournaments}
            games={data.games}
            onSelectTeam={(team) => {
              setActiveTeam(team);
              // Default to Players Tab
              setActiveTab('players');
              // Reset active tournament
              setActiveTournament(null);
            }}
            onAddTeam={() => setModalType('team')}
            onEditTeam={(team) => { setEditItem(team); setModalType('team'); }}
            onDeleteTeam={(team) => handleDeleteTeam(team.id)}
            onDemoData={loadMockData}
            onImportData={handleImportData}
            onOpenHelp={() => setModalType('help')}
          />
        </div>
        <AppModals
          modalType={modalType}
          editItem={editItem}
          activeTeam={activeTeam}
          activeTournament={activeTournament}
          data={data}
          onClose={() => { setModalType(null); setEditItem(null); }}
          onSaveTeam={handleSaveTeam}
          onSaveTournament={handleSaveTournament}
          onSavePlayer={handleSavePlayer}
          onSaveGame={handleSaveGame}
          onDeletePlayer={handleDeletePlayer}
          onDeleteGame={handleDeleteGame}
          onBulkImportPlayers={handleBulkImportPlayers}
          onStorageReset={handleStorageReset}
        />
      </div>
    );
  }

  // Dynamic Tabs - REPLACED BY SIDEBAR
  // const currentTabs = ...

  const getCurrentStep = () => {
    if (['team', 'players'].includes(activeTab)) return 1;
    return 2;
  };

  return (
    <div className="app">
      <AppHeader
        activeTeam={activeTeam}
        saveStatus={saveStatus}
        lastSaveTime={lastSaveTime}
        onManualSave={handleManualSave}
        onSwitchTeam={() => setActiveTeam(null)}
        onOpenStorage={() => setModalType('storage')}
        data={data}
        filteredPlayers={filteredPlayers}
        searchGames={searchGames}
        onNavigateSearch={(target) => {
          setHighlightedItemId(target.item.id);
          if (target.type === 'player') {
            setActiveTournament(null);
            // Wait slightly for tab switch before highlighting to ensure DOM is ready
            setTimeout(() => setActiveTab('players'), 0);
          } else {
            setActiveTournament(target.tournament);
            setTimeout(() => setActiveTab('games'), 0);
          }
        }}
        onOpenHelp={() => setModalType('help')}
      />




      {/* Mock data banner */}
      {useMockData && (
        <div className="banner info" style={{
          padding: '8px 16px',
          textAlign: 'center',
          fontSize: '0.875rem',
          fontWeight: '500'
        }}>
          üí° Viewing demo data.
          <button
            onClick={loadMockData}
            className="btn-link"
            style={{ color: 'white', marginLeft: 'var(--space-md)' }}
          >
            Save as my data
          </button>
          <span style={{ margin: '0 var(--space-sm)', opacity: 0.8 }}>or</span>
          <button
            onClick={() => { setUseMockData(false); setModalType('team'); }}
            className="btn-link"
            style={{ color: 'white' }}
          >
            Start fresh
          </button>
        </div>
      )}

      <div className="app-container">
        <Sidebar
          activeTab={activeTab}
          setActiveTab={(tab) => {
            setActiveTab(tab);
            setHighlightedItemId(null); // Clear highlight on manual tab change
          }}
          activeTeam={activeTeam}
          activeTournament={activeTournament}
          onExitTournament={() => {
            setActiveTournament(null);
            setActiveTab('tournaments');
            setHighlightedItemId(null);
          }}
        />

        <main className="app-content">
          <HierarchyStepper
            currentStep={getCurrentStep()}
            onStepClick={(s) => {
              if (s === 1) {
                // Go to Organization view
                setActiveTournament(null);
                setActiveTab('team');
              }
              if (s === 2) {
                // Go to Events view
                setActiveTab('tournaments');
              }
            }}
          />

          {/* Persistent Context Header */}
          <div className="dash-header-bar" style={{
            padding: 'var(--space-lg) var(--space-xl)',
            display: 'flex',
            justifyContent: 'space-between',
            alignItems: 'flex-start',
            borderBottom: '1px solid var(--border-light)',
            marginBottom: 'var(--space-lg)'
          }}>
            <div style={{ display: 'flex', flexDirection: 'column', gap: 'var(--space-md)' }}>
              <div>
                <h2 className="text-bold" style={{ fontSize: '1.5rem', letterSpacing: '-0.02em', textTransform: 'uppercase' }}>
                  {activeTab === 'team' && 'Team Overview'}
                  {activeTab === 'players' && 'Roster Management'}
                  {activeTab === 'tournaments' && 'Event Management'}
                  {activeTab === 'games' && 'Game Log'}
                  {activeTab === 'stats' && 'Performance Stats'}
                </h2>
              </div>

              <div style={{ display: 'flex', gap: 'var(--space-md)', flexWrap: 'wrap' }}>
                {activeTeam && (
                  <div className="identity-badge" onClick={() => { setEditItem(activeTeam); setModalType('team'); }} style={{ cursor: 'pointer' }}>
                    <div className="identity-icon">ü•é</div>
                    <div className="identity-info">
                      <span className="identity-label">Active Team</span>
                      <span className="identity-name">{activeTeam.name}</span>
                    </div>
                    <span style={{ fontSize: '0.7rem', marginLeft: '4px', opacity: 0.5 }}>‚öôÔ∏è</span>
                  </div>
                )}
                {activeTournament && (
                  <div className="identity-badge" onClick={() => { setEditItem(activeTournament); setModalType('tournament'); }} style={{ cursor: 'pointer', borderColor: 'var(--avg)' }}>
                    <div className="identity-icon" style={{ background: 'var(--avg)' }}>üèÜ</div>
                    <div className="identity-info">
                      <span className="identity-label">Active Event</span>
                      <span className="identity-name">{activeTournament.name}</span>
                    </div>
                    <span style={{ fontSize: '0.7rem', marginLeft: '4px', opacity: 0.5 }}>‚öôÔ∏è</span>
                  </div>
                )}
              </div>
            </div>
          </div>


          <AppContent
            activeTab={activeTab}
            activeTeam={activeTeam}
            activeTournament={activeTournament}
            data={data}
            filteredTournaments={filteredTournaments}
            filteredPlayers={filteredPlayers}
            filteredGames={filteredGames}
            teamGames={searchGames}
            highlightedItemId={highlightedItemId}
            onSetActiveTab={(tab) => {
              setActiveTab(tab);
              setHighlightedItemId(null);
            }}
            onSetActiveTournament={(t) => {
              setActiveTournament(t);
              setHighlightedItemId(null);
            }}
            onAddPlayer={() => { setEditItem(null); setModalType('player'); }}
            onAddGame={() => { setEditItem(null); setModalType('game'); }}
            onAddTournament={() => { setEditItem(null); setModalType('tournament'); }}
            onEditTeam={(t) => { setEditItem(t); setModalType('team'); }}
            onEditPlayer={(p) => { setEditItem(p); setModalType('player'); }}
            onEditGame={(g) => { setEditItem(g); setModalType('game'); }}
            onEditTournament={(t) => { setEditItem(t); setModalType('tournament'); }}
            onDeleteTeam={(id) => handleDeleteTeam(id)}
            onDeleteTournament={(id) => handleDeleteTournament(id)}
          />

          <AppModals
            modalType={modalType}
            editItem={editItem}
            activeTeam={activeTeam}
            activeTournament={activeTournament}
            data={data}
            onClose={() => { setModalType(null); setEditItem(null); }}
            onSaveTeam={handleSaveTeam}
            onSaveTournament={handleSaveTournament}
            onSavePlayer={handleSavePlayer}
            onSaveGame={handleSaveGame}
            onDeletePlayer={handleDeletePlayer}
            onDeleteGame={handleDeleteGame}
            onBulkImportPlayers={handleBulkImportPlayers}
            onStorageReset={handleStorageReset}
          />
        </main>
      </div>
    </div>
  );
}

export default App;
